ðŸ”‘ Ideal Flow for Spring Boot CI/CD (with quality checks)

1. Source Stage â†’ CodePipeline pulls code from GitHub.
âœ… Already handled by pipeline, so CodeBuild gets the repo automatically (no need for checkout in buildspec.yml).


2. Build Stage (CodeBuild with buildspec.yml)
Inside buildspec weâ€™ll do:

Install dependencies (Java, Maven, Docker, SonarScanner â€“ usually available in CodeBuild standard image).

Run JUnit tests.

Generate Jacoco coverage report.

Run SonarQube analysis.

Build Spring Boot JAR.

Build Docker image with JAR inside.

Push image to Docker Hub.





---

âœ… Final buildspec.yml

version: 0.2

env:
  variables:
    IMAGE_NAME: springboot-app
    DOCKER_HUB_USER: your-dockerhub-username
    DOCKER_HUB_REPO: your-dockerhub-username/springboot-app
  secrets-manager:
    DOCKER_HUB_PASS: dockerhub/credentials:password   # Store in Secrets Manager
    SONAR_TOKEN: sonarqube/credentials:token          # Store SonarQube token in Secrets Manager

phases:
  install:
    runtime-versions:
      java: corretto17
      docker: 20
    commands:
      - echo "Installing Maven..."
      - mvn -v
      - java -version
      - docker -v

  pre_build:
    commands:
      - echo "Logging in to Docker Hub..."
      - echo $DOCKER_HUB_PASS | docker login -u $DOCKER_HUB_USER --password-stdin
      - echo "Running Unit Tests..."
      - mvn clean verify
      - echo "Running SonarQube analysis..."
      - mvn sonar:sonar \
          -Dsonar.projectKey=springboot-app \
          -Dsonar.host.url=https://sonarcloud.io \
          -Dsonar.login=$SONAR_TOKEN

  build:
    commands:
      - echo "Building JAR..."
      - mvn clean package -DskipTests
      - echo "Building Docker Image..."
      - docker build -t $IMAGE_NAME:$CODEBUILD_RESOLVED_SOURCE_VERSION .
      - docker tag $IMAGE_NAME:$CODEBUILD_RESOLVED_SOURCE_VERSION $DOCKER_HUB_REPO:$CODEBUILD_RESOLVED_SOURCE_VERSION
      - docker tag $IMAGE_NAME:$CODEBUILD_RESOLVED_SOURCE_VERSION $DOCKER_HUB_REPO:latest

  post_build:
    commands:
      - echo "Pushing Docker image to Docker Hub..."
      - docker push $DOCKER_HUB_REPO:$CODEBUILD_RESOLVED_SOURCE_VERSION
      - docker push $DOCKER_HUB_REPO:latest
      - echo "Build completed successfully!"

artifacts:
  files:
    - target/*.jar


---

ðŸ”Ž Explanation of Each Phase

env

Defines image name, Docker Hub repo, credentials from AWS Secrets Manager, and SonarQube token.

This keeps secrets secure.


install

Uses AWS CodeBuild managed image (aws/codebuild/standard:6.0 or newer) with Java 17 + Docker 20.

Ensures Java, Maven, Docker available.


pre_build

Login to Docker Hub.

Run JUnit tests (mvn clean verify runs tests + Jacoco coverage).

Send code quality results to SonarQube/SonarCloud.


build

Build JAR.

Build Docker image with version = commit ID ($CODEBUILD_RESOLVED_SOURCE_VERSION).

Tag image with :latest also.


post_build

Push both versioned image and latest to Docker Hub.

Save .jar in CodePipeline artifacts (so deployment stage can use if needed).




---

âš¡ Improvements you can add later

Fail pipeline if test coverage < 80% (jacoco-maven-plugin with thresholds).

Push image to ECR (instead of Docker Hub) for production deployments.

Add a separate Deploy stage to EKS/ECS.



---

ðŸ‘‰ This flow is production-grade:

âœ… Unit tests + coverage

âœ… SonarQube integration

âœ… Artifact (.jar)

âœ… Docker image in registry



---

Perfect ðŸ‘ Rushi, letâ€™s make your Spring Boot + Maven project fully ready for testing, coverage, and SonarQube.

Hereâ€™s the pom.xml configuration for:

1. âœ… JUnit 5 tests


2. âœ… JaCoCo for code coverage


3. âœ… SonarQube integration




---

ðŸ”¹ Add Plugins in pom.xml

<project>
  ...
  <properties>
    <java.version>17</java.version>
    <maven.compiler.source>${java.version}</maven.compiler.source>
    <maven.compiler.target>${java.version}</maven.compiler.target>
    <sonar.java.coveragePlugin>jacoco</sonar.java.coveragePlugin>
    <jacoco.version>0.8.11</jacoco.version>
  </properties>

  <build>
    <plugins>
      
      <!-- Compiler Plugin -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
        <configuration>
          <release>${java.version}</release>
        </configuration>
      </plugin>

      <!-- JUnit Platform (Surefire) -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>3.2.5</version>
        <configuration>
          <useModulePath>false</useModulePath>
        </configuration>
      </plugin>

      <!-- JaCoCo Code Coverage -->
      <plugin>
        <groupId>org.jacoco</groupId>
        <artifactId>jacoco-maven-plugin</artifactId>
        <version>${jacoco.version}</version>
        <executions>
          <!-- Attach JaCoCo agent -->
          <execution>
            <id>prepare-agent</id>
            <goals>
              <goal>prepare-agent</goal>
            </goals>
          </execution>
          <!-- Generate report after tests -->
          <execution>
            <id>report</id>
            <phase>verify</phase>
            <goals>
              <goal>report</goal>
            </goals>
          </execution>
          <!-- Fail build if coverage < 80% -->
          <execution>
            <id>check</id>
            <goals>
              <goal>check</goal>
            </goals>
            <configuration>
              <rules>
                <rule>
                  <element>CLASS</element>
                  <limits>
                    <limit>
                      <counter>LINE</counter>
                      <value>COVEREDRATIO</value>
                      <minimum>0.80</minimum>
                    </limit>
                  </limits>
                </rule>
              </rules>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <!-- SonarQube Scanner -->
      <plugin>
        <groupId>org.sonarsource.scanner.maven</groupId>
        <artifactId>sonar-maven-plugin</artifactId>
        <version>3.11.0.3922</version>
      </plugin>
      
    </plugins>
  </build>

  <dependencies>
    <!-- JUnit 5 -->
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter</artifactId>
      <version>5.11.0</version>
      <scope>test</scope>
    </dependency>

    <!-- Mockito (for mocking in unit tests) -->
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <version>5.13.0</version>
      <scope>test</scope>
    </dependency>

    <!-- Spring Boot Test -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>


---

ðŸ”¹ What Happens in the Pipeline

mvn clean verify

Runs unit tests (Surefire + JUnit 5).

Generates JaCoCo report (target/site/jacoco/index.html).

Fails build if coverage < 80%.


mvn sonar:sonar

Uploads test + coverage data to SonarQube/SonarCloud.

Requires sonar.projectKey, sonar.host.url, and sonar.login (token).




---

ðŸ”¹ SonarQube Properties (Optional sonar-project.properties file)

If you donâ€™t want to pass everything in buildspec.yml, you can add this in project root:

sonar.projectKey=springboot-app
sonar.projectName=SpringBoot Application
sonar.java.binaries=target/classes
sonar.sources=src/main/java
sonar.tests=src/test/java
sonar.junit.reportPaths=target/surefire-reports
sonar.jacoco.reportPaths=target/jacoco.exec
sonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml
sonar.host.url=https://sonarcloud.io


---

ðŸ“Š Example Build Flow with This Setup

1. Unit tests run â†’ mvn test


2. JaCoCo generates coverage â†’ enforces 80% min coverage


3. SonarQube analysis â†’ code smells, bugs, vulnerabilities, coverage %


4. If success â†’ JAR built â†’ Docker image built â†’ Pushed to Docker Hub




---

ðŸ‘‰ This setup ensures CI/CD = Quality Gate + Deployment.




